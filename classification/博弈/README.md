博弈问题
===

最常见的SG博弈：
---

1. 二人博弈
2. 对于同一局面，两者可以操作的集合完全相同
3. 游戏总可以在有限步数内结束。
4. 假定2人都"足够聪明"
5. 游戏无法操作时，不能操作的一方为负。
    也可能有不能操作为胜的局面

取石子问题：
---
1. 取石子1:
    有一堆n个石子，两个人轮流取，每次可以取1..m个，没得取判负。
2. 取石子2:
    有k堆石子，每堆n\_i个，两个轮流取，每次可以从某一堆中取1..m个
    没得取判负。

N局面和P局面：
---

- 必须在有限步内结束
- 双方都猜取最佳策略的前提下，任一局面不是先手胜利就是后手胜利。
- 规定：先手胜为N局面，后手胜利为P局面
<br/>
- 此类问题一般问某一个局面时先手必胜还是先手必败。
    - 附加问题:先手必胜时，输出当前一步可以选步
- 最终局面都是P局面
- 对于一个局面，至少有一种操作是他变成P局面，则他是N局面
- 对于一个局面，无论如何操作都使他变成N局面，则他是P局面
- 例如：取石子问题
    - 有一堆n个石子，两人轮流取，每次可以去1..m个，没得取的判负
    - 在游戏中，n不断变化，m是定植
    - 一个局面可以用当前的石子数n来表示
    - n = 0必败
    n = 1..m都是必胜局面
    n = m+1 是必败局面
    n = m+2 .. 2m+1 是必胜局面 
将博弈游戏看作图
---

- 将游戏的中间状态看作顶点
    - 性质2：对于用一局面，两个游戏者可操作的集合完全相同。
    点对当前的执行者是无差别的。
- 将状态转移看作边
    - 性质三： 游戏总可以在有限步之内结束
    这是一个有向无环图
![取石子问题示例](pic/取石子问题示例.jpg)

顶点必胜必败态 --- - 每个顶点队会对应N局面必胜或者P局面必败
    - N点（必胜点）或者P点（必败点）
- 如果顶点有边指向P点，则该点为N点.
- 如果顶点没有边指向P点，则该点为P点。
![取石子问题示例2](pic/取石子问题示例2.jpg)

判断先手必胜还是必败
---

- 图是[有向无环图]
- 通过拓扑排序对图的每个点进行染色，从而确定每个点的状态
    - 必胜时要输出一个可行解：寻找该状态对应的N节点指向P节点的那条边。
- 算法复杂度和状态数有关
- 一堆石子的状态数为N
- K堆石子的状态是一个K维向量<n1, n2, ... nk>
    - 状态数为n1 \* n2 \* ... \* nk
    - 过多。

SG函数

---
- 对顶点赋一个SG值
- 设顶点V，有V-\>v1, v-\>v2, ... v-\>vt
- sg(v) = min(N - {sg(v1), sg(v2), ...sg(vt)})
- sg(v)定义为没有出现在{sg(v1)...sg(vt)}中的最小自然数
- 同样可以用拓扑序对节点计算sg值

SG函数与NP局面的关系
---

- 初始节点（必须是P节点）没有出边，
    sg = 0
- 若V有边指向某sg(vi) = 0的vi, 则sg(v)>0
- 若v没有边指向某sg(vi) = 0的vi, 则sg(v) = 0
<br/>
- 所有P节点sg=0
- 所有N节点sg>0
![取石子问题实例3](pic/取石子问题实例3.jpg)

取石子游戏
---

- 一维：只有一堆石子
- n先手必胜当且仅当sg(n)>0
- 二维的石子游戏：两堆石子n1, n2
- 状态：\<n1, n2\>
- sg(\<n1, n2\>) = ?
- 断言：sg(\<n1, n2\>) = sg(n1)^sg(n2)
    - 两个一维sg函数的异或

sg(<n1, n2>) = sg(n1)^sg(n2)
---

- 证明要点： sg(\<n1, n2\>)=sg(n1)^sg(n2)
    满足sg函数的性质
- 若 sg(\<n1, n2\>) = x, 则存在操作使得\<n1, n2\> -\> \<n3, n4\>
且sg(\<n3, n4\>) = 0..x-1
- 若 sg(\<n1, n2\>) = x 不存在操作使得\<n1, n2\> -\> \<n3, n4\>
且sg(\<n3, n4\>) = x
