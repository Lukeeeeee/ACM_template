动态规划
===

各种初步动态规划的复杂度，以及状态转移方程

数字三角形
---

```c
// d(i, j) = a(i, j) + max{d(i, j), d(i+1, j+1)}
void cal(int n)
{
    for(int i = n-1; i >= 0; i--)
        for(int j = 0; j <= i; j++)
            dp[i][j] = a[i][j] + max(dp[i+1][j], dp[i+1][j+1]);
}
```

嵌套矩形
---

硬币问题
---

01背包问题
---

思路：使用最大价值的子集，尽可能的填满空集，求最大价值

dp方程（经过滚动优化）：

dp[v] = max(dp[v], dp[v- w[i]] + v[i])

点集配对问题
---

最长上升子序列问题（LIS）
---

- d[i]表示以下标i结尾的最长上升子序列的长度
- g[i]表示d值为i的最小状态编号
如此一来，可以通过下列方法更新求出最大值.
g中会把数列A中的小数不停的排在g里面，换个思路：

将 A数列中的数字放在g中，如果大放在最后面，如果不大就代替掉前面的数字，每次返回的k是上升子
序列的长度，每次都与最大值ans进行判断，算法的复杂度为$nlogn$。

```c
        for(int i = 1; i <= n; i++) g[i] = INF;
        int ans = 0;
        for(int i = 0; i < n; i++) {
            int k = lower_bound(g+1, g+n+1, S[i]) - g;
            d[i] = k;
            g[k] = S[i];
            ans = max(ans, k);
        }
```

最长公共子序列问题（LCS）
---

货担郎问题(TSP)
---

矩阵链乘(MCM)
---

$$f(i,j) = max{f(i,k)+ f(k,j)+ p_{i-1}p_{k}p_{j}} $$

需要按照j-i递增的方式递推。记忆化搜索没有问题。

最有排序二叉树问题（OBST）
---


